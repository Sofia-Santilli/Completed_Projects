<!DOCTYPE html>
<html>
<body>

<canvas id="gl-canvas" width="512" height="512"></canvas>


<p> ROTATION AROUND THE xyz AXIS:  </p> 
<button id = "ButtonX">Rotate X</button>
<button id = "ButtonY">Rotate Y</button>
<button id = "ButtonZ">Rotate Z</button>
<button id = "ButtonT">Toggle Rotation</button>
<button id = "ButtonDir">Change direction</button>

 <p> CHANGE THE VIEWER POSITION and VIEWER VOLUME:  </p>
<button id = "Button1">Increase Z</button>
<button id = "Button2">Decrease Z</button>
<button id = "Button3">Increase R</button>
<button id = "Button4">Decrease R</button>

<button id = "Button5">Increase theta</button>
<button id = "Button6">Decrease theta</button>
<button id = "Button7">Increase phi</button>
<button id = "Button8">Decrease phi</button>

<p> SWITCH BETWEEN PER-VERTEX (default) AND PER-FRAGMENT SHADING MODELS:  
<button id = "ButtonSwitch">switch shading</button>
</p>

<p> SWITCH 3 LIGHTS ON/OFF:  
<button id = "threelights">switch 3 lights</button>
</p>

<p> SWITCH ROUGH SURFACE:  
<button id = "bumpBotton">switch rough surface</button>
</p>




<script id="vertex-shader" type="x-shader/x-vertex">
#version 300 es

precision mediump float;

in vec4 aPosition;
in vec3 aNormal;
in vec2 aTexCoord;
in vec4 aTangent;

out vec4 vColor;
out vec3 N, L, E;
out vec2 vTexCoord;
out vec3 L_r, L_r2, L_r3;

out vec3 V;


uniform vec4 uAmbientProductR, uDiffuseProductR, uSpecularProductR;
uniform vec4 uLightPositionR;
uniform vec4 uLightPositionR2;
uniform vec4 uLightPositionR3;

uniform vec4 uAmbientProduct, uDiffuseProduct, uSpecularProduct;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec4 uLightPosition;
uniform float uShininess;
uniform mat3 uNormalMatrix;


uniform bool uShadingFlag;
uniform bool uThreeFlag;
uniform bool uBumpFlag;

void main()
{

    if(uBumpFlag){
	vec3 eyePosition = -(uModelViewMatrix*aPosition).xyz;
	vec3 eyeLightPos = (uModelViewMatrix*uLightPosition).xyz;

	vec3 N = normalize(uNormalMatrix*aNormal.xyz);
	vec3 T = normalize(uNormalMatrix*aTangent.xyz); //*uObjTangent);
	vec3 B = cross(N, T);

	L.x = dot(T, eyeLightPos-eyePosition);
	L.y = dot(B, eyeLightPos-eyePosition);
	L.z = dot(N, eyeLightPos-eyePosition);
	L = normalize(L);

	V.x = dot(T, -eyePosition);
	V.y = dot(B, -eyePosition);
	V.z = dot(N, -eyePosition);
	V = normalize(V);
    }

    else{

        vec3 pos = -(uModelViewMatrix * aPosition).xyz;

        L = normalize(uLightPosition.xyz - pos);
        L_r = normalize(uLightPositionR.xyz - pos); 
        L_r2 = normalize(uLightPositionR2.xyz - pos); 
        L_r3 = normalize(uLightPositionR3.xyz - pos); 

        E = normalize(-pos);

        // Transform vertex normal into eye coordinates
        N = normalize(uNormalMatrix*aNormal.xyz);  //Normal.xyz);

        if(!uShadingFlag){
           vec3 H = normalize(L + E);
           vec3 H_r = normalize(L_r + E);
           vec3 H_r2 = normalize(L_r2 + E);
           vec3 H_r3 = normalize(L_r3 + E);

           // Compute terms in the illumination equation
           vec4 ambient = uAmbientProduct;
           vec4 ambient_r = uAmbientProductR;

           float Kd = max(dot(L, N), 0.0);
           vec4  diffuse = Kd*uDiffuseProduct;    
           float Kd_r = max(dot(L_r, N), 0.0); 
           vec4  diffuse_r = Kd_r*uDiffuseProductR; 
           float Kd_r2 = max(dot(L_r2, N), 0.0); 
           vec4  diffuse_r2 = Kd_r2*uDiffuseProductR; 
           float Kd_r3 = max(dot(L_r3, N), 0.0); 
           vec4  diffuse_r3 = Kd_r3*uDiffuseProductR; 
  
           float Ks = pow( max(dot(N, H), 0.0), uShininess );
           vec4  specular = Ks * uSpecularProduct;
           float Ks_r = pow( max(dot(N, H_r), 0.0), uShininess );
           vec4  specular_r = Ks_r * uSpecularProductR;
           float Ks_r2 = pow( max(dot(N, H_r2), 0.0), uShininess );
           vec4  specular_r2 = Ks_r2 * uSpecularProductR;
           float Ks_r3 = pow( max(dot(N, H_r3), 0.0), uShininess );
           vec4  specular_r3 = Ks_r3 * uSpecularProductR;

           if( dot(L, N) < 0.0) {
               specular = vec4(0.0, 0.0, 0.0, 1.0);
           }

           if(dot(L_r, N) < 0.0) {
               specular_r = vec4(0.0, 0.0, 0.0, 1.0);
           }
           if(dot(L_r2, N) < 0.0) {
               specular_r2 = vec4(0.0, 0.0, 0.0, 1.0);
           }
           if(dot(L_r3, N) < 0.0) {
               specular_r3 = vec4(0.0, 0.0, 0.0, 1.0);
           }

           vColor = ambient + diffuse + specular;
           if(uThreeFlag){
               vColor = vColor + ambient_r + ambient_r + ambient_r + diffuse_r + diffuse_r2 + diffuse_r3 + specular_r + specular_r2 + specular_r3 ;
           }
           vColor.a = 1.0;
        }

    }

    gl_Position = uProjectionMatrix * uModelViewMatrix *aPosition;

    vTexCoord = aTexCoord;


}
</script>




<script id="fragment-shader" type="x-shader/x-fragment">
#version 300 es

precision mediump float;

in vec3 N, L, E;
in vec3 L_r, L_r2, L_r3;
in vec4 vColor;
in vec2 vTexCoord;

out vec4 fColor;

uniform vec4 uAmbientProductR, uDiffuseProductR, uSpecularProductR;

uniform vec4 uAmbientProduct, uDiffuseProduct, uSpecularProduct;
uniform float uShininess;
uniform sampler2D uTextureMap;

uniform bool uShadingFlag;
uniform bool uThreeFlag;
uniform bool uBumpFlag;


void main()
{
    if(uBumpFlag){

	//vec4 
	vec4 N = texture(uTextureMap, vTexCoord);
	vec3 NN = normalize(2.0 * N.xyz - 1.0);
	vec3 LL = normalize(L);
	float Kd = max(dot(NN, LL), 0.0);

	fColor = vec4(Kd*uDiffuseProduct.xyz, 1.0);

    }

    else if(uShadingFlag){

	//uf(uBumpFlag)
        vec3 H = normalize(L+E);
        vec3 H_r = normalize(L_r+E);
        vec3 H_r2 = normalize(L_r2+E);
        vec3 H_r3 = normalize(L_r3+E); ///


        vec4 ambient = uAmbientProduct;
        vec4 ambient_r = uAmbientProductR; ///

        float Kd = max(dot(L, N), 0.0);
        vec4  diffuse = Kd*uDiffuseProduct;
        float Kd_r = max(dot(L_r, N), 0.0); ///
        vec4  diffuse_r = Kd_r*uDiffuseProductR; /// 
        float Kd_r2 = max(dot(L_r2, N), 0.0); 
        vec4  diffuse_r2 = Kd_r2*uDiffuseProductR; 
        float Kd_r3 = max(dot(L_r3, N), 0.0); 
        vec4  diffuse_r3 = Kd_r3*uDiffuseProductR; 

        float Ks = pow( max(dot(N, H), 0.0), uShininess );
        vec4  specular = Ks * uSpecularProduct;
        float Ks_r = pow( max(dot(N, H_r), 0.0), uShininess );
        vec4  specular_r = Ks_r * uSpecularProductR;
        float Ks_r2 = pow( max(dot(N, H_r2), 0.0), uShininess );
        vec4  specular_r2 = Ks_r2 * uSpecularProductR;
        float Ks_r3 = pow( max(dot(N, H_r3), 0.0), uShininess );
        vec4  specular_r3 = Ks_r3 * uSpecularProductR;

        if( dot(L, N) < 0.0 ) {
	    specular = vec4(0.0, 0.0, 0.0, 1.0);
        }
        if( dot(L_r, N) < 0.0 ) {
	    specular_r = vec4(0.0, 0.0, 0.0, 1.0);
        }
        if(dot(L_r2, N) < 0.0) {
            specular_r2 = vec4(0.0, 0.0, 0.0, 1.0);
        }
        if(dot(L_r3, N) < 0.0) {
            specular_r3 = vec4(0.0, 0.0, 0.0, 1.0);
        }

        vec4 cColor;
        cColor = (ambient + diffuse +specular);
        if(uThreeFlag){
            cColor = cColor + ambient_r + ambient_r + ambient_r + diffuse_r + diffuse_r2 + diffuse_r3 + specular_r + specular_r2 + specular_r3 ;
        }
        cColor.a = 1.0;
        fColor = cColor*texture(uTextureMap, vTexCoord);
    }
    else{
        fColor = vColor*texture(uTextureMap, vTexCoord);
    }
}
</script>










<script id="vertex-shader2" type="x-shader/x-vertex">
#version 300 es

precision mediump float;

in  vec4 aPosition;
in  vec3 aNormal;

out vec4 vColor;
out vec3 N, L, E;
out vec3 L_r, L_r2, L_r3;


uniform vec4 uAmbientProductR, uDiffuseProductR, uSpecularProductR;
uniform vec4 uLightPositionR;
uniform vec4 uLightPositionR2;
uniform vec4 uLightPositionR3;

uniform vec4 uAmbientProduct, uDiffuseProduct, uSpecularProduct;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec4 uLightPosition;
uniform float uShininess;
uniform mat3 uNormalMatrix;
uniform vec4 uEmissiveCyl;

uniform bool uShadingFlag;
uniform bool uThreeFlag;


void main()
{

    vec3 pos = -(uModelViewMatrix * aPosition).xyz;

    L = normalize(uLightPosition.xyz - pos);
    L_r = normalize(uLightPositionR.xyz - pos); 
    L_r2 = normalize(uLightPositionR2.xyz - pos); 
    L_r3 = normalize(uLightPositionR3.xyz - pos); 


    //vec3 
    E = normalize(-pos);

    // Transform vertex normal into eye coordinates
    N = normalize(uNormalMatrix*aNormal.xyz);  //Normal.xyz);

    if(!uShadingFlag){
       vec3 H = normalize(L + E);
       vec3 H_r = normalize(L_r + E);
       vec3 H_r2 = normalize(L_r2 + E);
       vec3 H_r3 = normalize(L_r3 + E);

       // Compute terms in the illumination equation
       vec4 ambient = uAmbientProduct;
       vec4 ambient_r = uAmbientProductR;

       float Kd = max(dot(L, N), 0.0);
       vec4  diffuse = Kd*uDiffuseProduct;
       float Kd_r = max(dot(L_r, N), 0.0); 
       vec4  diffuse_r = Kd_r*uDiffuseProductR; 
       float Kd_r2 = max(dot(L_r2, N), 0.0); 
       vec4  diffuse_r2 = Kd_r2*uDiffuseProductR; 
       float Kd_r3 = max(dot(L_r3, N), 0.0); 
       vec4  diffuse_r3 = Kd_r3*uDiffuseProductR; 
 
       float Ks = pow( max(dot(N, H), 0.0), uShininess );
       vec4  specular = Ks * uSpecularProduct;
       float Ks_r = pow( max(dot(N, H_r), 0.0), uShininess );
       vec4  specular_r = Ks_r * uSpecularProductR;
       float Ks_r2 = pow( max(dot(N, H_r2), 0.0), uShininess );
       vec4  specular_r2 = Ks_r2 * uSpecularProductR;
       float Ks_r3 = pow( max(dot(N, H_r3), 0.0), uShininess );
       vec4  specular_r3 = Ks_r3 * uSpecularProductR;

       if( dot(L, N) < 0.0 ) {
	     specular = vec4(0.0, 0.0, 0.0, 1.0);
       }
       if(dot(L_r, N) < 0.0) {
           specular_r = vec4(0.0, 0.0, 0.0, 1.0);
       }
       if(dot(L_r2, N) < 0.0) {
           specular_r2 = vec4(0.0, 0.0, 0.0, 1.0);
       }
       if(dot(L_r3, N) < 0.0) {
           specular_r3 = vec4(0.0, 0.0, 0.0, 1.0);
       }

       vColor = ambient + diffuse +specular;
       if(uThreeFlag){
           vColor = vColor + ambient_r + ambient_r + ambient_r + diffuse_r + diffuse_r2 + diffuse_r3 + specular_r + specular_r2 + specular_r3 + uEmissiveCyl;
       }
       vColor.a = 0.7; //1.0;       
    }

    gl_Position = uProjectionMatrix * uModelViewMatrix *aPosition;

    //vTexCoord = aTexCoord;
}
</script>




<script id="fragment-shader2" type="x-shader/x-fragment">
#version 300 es

precision mediump float;

in vec3 N, L, E;
in vec3 L_r, L_r2, L_r3;
in vec4 vColor;


out vec4 fColor;

uniform vec4 uAmbientProductR, uDiffuseProductR, uSpecularProductR;

uniform vec4 uAmbientProduct, uDiffuseProduct, uSpecularProduct;
uniform float uShininess;
uniform vec4 uEmissiveCyl;

uniform bool uShadingFlag;
uniform bool uThreeFlag;


void main()
{

    if(uShadingFlag){
        vec3 H = normalize(L+E);
        vec3 H_r = normalize(L_r+E);
        vec3 H_r2 = normalize(L_r2+E);
        vec3 H_r3 = normalize(L_r3+E);

        vec4 ambient = uAmbientProduct;
        vec4 ambient_r = uAmbientProductR; 

        float Kd = max(dot(L, N), 0.0);
        vec4  diffuse = Kd*uDiffuseProduct;
        float Kd_r = max(dot(L_r, N), 0.0); ///
        vec4  diffuse_r = Kd_r*uDiffuseProductR; /// 
        float Kd_r2 = max(dot(L_r2, N), 0.0); 
        vec4  diffuse_r2 = Kd_r2*uDiffuseProductR; 
        float Kd_r3 = max(dot(L_r3, N), 0.0); 
        vec4  diffuse_r3 = Kd_r3*uDiffuseProductR; 

        float Ks = pow( max(dot(N, H), 0.0), uShininess );
        vec4  specular = Ks * uSpecularProduct;
        float Ks_r = pow( max(dot(N, H_r), 0.0), uShininess );
        vec4  specular_r = Ks_r * uSpecularProductR;
        float Ks_r2 = pow( max(dot(N, H_r2), 0.0), uShininess );
        vec4  specular_r2 = Ks_r2 * uSpecularProductR;
        float Ks_r3 = pow( max(dot(N, H_r3), 0.0), uShininess );
        vec4  specular_r3 = Ks_r3 * uSpecularProductR;

        if( dot(L, N) < 0.0 ) {
	      specular = vec4(0.0, 0.0, 0.0, 1.0);
        }
        if( dot(L_r, N) < 0.0 ) {
	    specular_r = vec4(0.0, 0.0, 0.0, 1.0);
        }
        if(dot(L_r2, N) < 0.0) {
            specular_r2 = vec4(0.0, 0.0, 0.0, 1.0);
        }
        if(dot(L_r3, N) < 0.0) {
            specular_r3 = vec4(0.0, 0.0, 0.0, 1.0);
        }

        vec4 cColor;
        cColor = (ambient + diffuse +specular);
        if(uThreeFlag){
            cColor = cColor + ambient_r + ambient_r + ambient_r + diffuse_r + diffuse_r2 + diffuse_r3 + specular_r + specular_r2 + specular_r3 + uEmissiveCyl;
        }
        cColor.a = 0.7;  //1.0;
        fColor = cColor; //*texture(uTextureMap, vTexCoord);

    }
    else{
        fColor = vColor; //*texture(uTextureMap, vTexCoord);
    }
}
</script>





<script src="../Common/initShaders.js"></script>
<script src="../Common/MVnew.js"></script>
<script src="Homework1.js"></script>


</body>
</html>
